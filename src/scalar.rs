//! A `Scalar` represents an element of the finite field
//! modulo `2^249 - 15145038707218910765482344729778085401`.
//!
//! The `Scalar` type is an alias for one of the backend
//! implementations.
//!
//! `ConstantTimeEq` and `PartialEq` traits have been implemented
//! here since they will be the samme across all of the different
//! backends.
//!
//! Here it is also defined the `Ristretto255Scalar` type,
//! which is a type-alias for the curve25519-dalek Scalar Struct.
//!
//! # Examples
//! ```rust
//! use zerocaf::scalar::Scalar;
//! use zerocaf::traits::ops::*;
//!
//! // You can create a Scalar from a byte-array as follows:
//! let a = Scalar::from_bytes(&[0u8;32]);
//!
//! // You ca also create a Scalar from an uint type as follows:
//! let b = Scalar::from(43325u128);
//! let c = Scalar::from(86650u64);
//!
//! // The last way of creating a Scalar it by calling the
//! // constructor. THIS IS NOT RECOMMENDED since ANY checks about
//! // the correctness of the input will be done. It can be done as
//! // follows:
//! let d: Scalar = Scalar([0, 1, 0, 0, 0]); // d = 2^52.
//! assert!(d == Scalar::two_pow_k(52u64));
//!
//! // All of the basuc modular operations are implemented
//! // for Scalar type:
//! let mut res = a + b; // Performs a + b (mod l).
//! res = a - b; // Performs a - b (mod l).
//! res = c * d; // Performs c * d (mod l).
//! res = a.square(); // Performs a^2 (mod l).
//! res = -&a; // Performs Negation over the modulo l.
//!
//! // Dividing even Scalars by two is recommended through the `Half`
//! // trait implmementation since it's much faster.
//! if a.is_even() {
//!     let half_c = c.half(); // This will panic if a isn't even.
//!     assert!(half_c == b);
//! }
//!
//! // You can export your `Scalar` as an slice of 32 bytes in Little
//! // Endian encoding by:
//! let d_bytes: [u8; 32] = d.to_bytes();
//! ```
//!
//!
//!
//! `PartialOrd`, `Ord`, `PartialEq` and `Eq` are also implemented for
//! `Scalar` type.
//!
//! All `std::core::ops traits -> (Add, Sub, Mul)` are implemented
//! for both, `&Scalar` and `Scalar`.

use std::ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign};

use crate::backend;
use crate::field::FieldElement;
use crate::traits::ops::Square;

use ff::{Field, FieldBits, PrimeField, PrimeFieldBits};

use subtle::{Choice, CtOption};
use subtle::{ConditionallySelectable, ConstantTimeEq};

use rand::{CryptoRng, Rng};

#[cfg(feature = "u64_backend")]
pub use backend::u64::scalar::*;
/// A `Scalar` represents an element of the field generated by
/// the prime of the sub-group: `2^249 - 15145038707218910765482344729778085401`.
///
/// This is a type alias for one of the Scalar types in the `backend`
/// module.
#[cfg(feature = "u64_backend")]
pub type Scalar = backend::u64::scalar::Scalar;

impl PartialEq for Scalar {
    fn eq(&self, other: &Scalar) -> bool {
        self.ct_eq(other).unwrap_u8() == 1u8
    }
}

impl ConstantTimeEq for Scalar {
    /// Test equality between two `Scalar`s.  Since the
    /// internal representation is not canonical, the field elements
    /// are normalized to wire format before comparison.
    fn ct_eq(&self, other: &Scalar) -> Choice {
        self.to_bytes().ct_eq(&other.to_bytes())
    }
}

impl Eq for Scalar {}

impl Scalar {
    /// Generate a valid Scalar choosen uniformly using user-
    /// provided rng.
    ///
    /// By `rng` we mean any Rng that implements: `Rng` + `CryptoRng`.
    pub fn random<T>(rand: &mut T) -> Scalar
    where
        T: Rng + CryptoRng,
    {
        let mut bytes = [0u8; 32];
        rand.fill_bytes(&mut bytes);
        // Ensure that the value is lower than `L`.
        bytes[31] &= 0b0000_0001;
        Scalar::from_bytes(&bytes)
    }
}

impl<'b> Add<&'b Scalar> for Scalar {
    type Output = Self;

    #[inline]
    fn add(self, rhs: &'b Scalar) -> Self::Output {
        self + *rhs
    }
}

impl<'a> Add<Scalar> for &'a Scalar {
    type Output = Scalar;

    #[inline]
    fn add(self, rhs: Scalar) -> Self::Output {
        *self + rhs
    }
}

impl AddAssign for Scalar {
    #[inline]
    fn add_assign(&mut self, rhs: Self) {
        *self = *self + rhs;
    }
}

impl<'b> AddAssign<&'b Scalar> for Scalar {
    #[inline]
    fn add_assign(&mut self, rhs: &'b Scalar) {
        *self = *self + rhs;
    }
}

impl<'b> Sub<&'b Scalar> for Scalar {
    type Output = Self;

    #[inline]
    fn sub(self, rhs: &'b Scalar) -> Self::Output {
        self - *rhs
    }
}

impl<'a> Sub<Scalar> for &'a Scalar {
    type Output = Scalar;

    #[inline]
    fn sub(self, rhs: Scalar) -> Self::Output {
        *self - rhs
    }
}

impl SubAssign for Scalar {
    #[inline]
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

impl<'b> SubAssign<&'b Scalar> for Scalar {
    #[inline]
    fn sub_assign(&mut self, rhs: &'b Scalar) {
        *self = *self - rhs;
    }
}

impl<'b> Mul<&'b Scalar> for Scalar {
    type Output = Self;

    #[inline]
    fn mul(self, rhs: &'b Scalar) -> Self::Output {
        self * *rhs
    }
}

impl<'a> Mul<Scalar> for &'a Scalar {
    type Output = Scalar;

    #[inline]
    fn mul(self, rhs: Scalar) -> Self::Output {
        *self * rhs
    }
}

impl MulAssign for Scalar {
    #[inline]
    fn mul_assign(&mut self, rhs: Self) {
        *self = *self * rhs;
    }
}

impl<'b> MulAssign<&'b Scalar> for Scalar {
    #[inline]
    fn mul_assign(&mut self, rhs: &'b Scalar) {
        *self = *self * rhs;
    }
}

impl ConditionallySelectable for Scalar {
    fn conditional_select(_a: &Self, _b: &Self, _choice: Choice) -> Self {
        unimplemented!()
    }
}

impl Field for Scalar {
    fn random(_rng: impl ff::derive::rand_core::RngCore) -> Self {
        unimplemented!()
    }

    fn zero() -> Self {
        Scalar::zero()
    }

    fn one() -> Self {
        Scalar::one()
    }

    fn is_zero(&self) -> Choice {
        self.ct_eq(&Self::zero())
    }

    fn is_zero_vartime(&self) -> bool {
        self.is_zero().into()
    }

    fn square(&self) -> Self {
        Square::square(self)
    }

    fn cube(&self) -> Self {
        Square::square(self) * self
    }

    fn double(&self) -> Self {
        self + self
    }

    fn invert(&self) -> subtle::CtOption<Self> {
        let fr = FieldElement::from_bytes(&self.to_bytes()).inverse();
        CtOption::new(
            Scalar::from_bytes_mod_order(&fr.to_bytes()),
            Choice::from(1u8),
        )
    }

    fn sqrt(&self) -> subtle::CtOption<Self> {
        unimplemented!()
    }

    fn pow_vartime<S: AsRef<[u64]>>(&self, exp: S) -> Self {
        let mut res = Self::one();
        for e in exp.as_ref().iter().rev() {
            for i in (0..64).rev() {
                res = Square::square(&res);

                if ((*e >> i) & 1) == 1 {
                    res.mul_assign(self);
                }
            }
        }

        res
    }
}

impl PrimeField for Scalar {
    type Repr = [u8; 32];

    fn from_str_vartime(s: &str) -> Option<Self> {
        if s.is_empty() {
            return None;
        }

        if s == "0" {
            return Some(Self::zero());
        }

        let mut res = Self::zero();

        let ten = Self::from(10u8);

        let mut first_digit = true;

        for c in s.chars() {
            match c.to_digit(10) {
                Some(c) => {
                    if first_digit {
                        if c == 0 {
                            return None;
                        }

                        first_digit = false;
                    }

                    res.mul_assign(&ten);
                    res.add_assign(&Self::from(u64::from(c)));
                }
                None => {
                    return None;
                }
            }
        }

        Some(res)
    }

    fn from_repr(bytes: Self::Repr) -> subtle::CtOption<Self> {
        CtOption::new(Scalar::from_bytes_mod_order(&bytes), Choice::from(1u8))
    }

    fn from_repr_vartime(repr: Self::Repr) -> Option<Self> {
        Self::from_repr(repr).into()
    }

    fn to_repr(&self) -> Self::Repr {
        Scalar::to_bytes(self)
    }

    fn is_odd(&self) -> Choice {
        !self.is_even()
    }

    fn is_even(&self) -> Choice {
        if Scalar::is_even(*self) {
            Choice::from(1u8)
        } else {
            Choice::from(0u8)
        }
    }

    const NUM_BITS: u32 = 256;

    const CAPACITY: u32 = 256;

    fn multiplicative_generator() -> Self {
        unimplemented!()
    }

    const S: u32 = 4;

    fn root_of_unity() -> Self {
        unimplemented!()
    }
}

impl PrimeFieldBits for Scalar {
    type ReprBits = [u8; 32];

    fn to_le_bits(&self) -> FieldBits<Self::ReprBits> {
        self.to_bytes().into()
    }

    fn char_le_bits() -> FieldBits<Self::ReprBits> {
        unimplemented!();
    }
}

/// This is a type alias for the Scalar type in the `curve25519-dalek` lib.
pub type Ristretto255Scalar = curve25519_dalek::scalar::Scalar;
